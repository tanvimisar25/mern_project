import React, { useState, useEffect, useCallback } from 'react';
import { Link } from "react-router-dom";
import { motion } from "framer-motion";
import './Questions.css';

import { useAuth } from './AuthContext';

// --- (Reusable Components & Data) ---
const Icon = ({ path, className = "icon" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
        <path d={path} />
    </svg>
);

const ICONS = {
    check: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z",
    x: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z",
    undo: "M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z",
    shuffle: "M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z",
    edit: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z",
};

// âœ… ADDED: Main and sub-category titles for the new data structure
const MAIN_CATEGORY_TITLE = "Web Development Concepts";
const SUB_CATEGORY_TITLE = "JavaScript Fundamentals";

const initialFlashcardQuestions = [
    { id: "js_1", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "What is the difference between == and === in JavaScript?", back: "The == operator performs a loose equality comparison, which means it will try to coerce the operands to the same type before comparing them (e.g., 5 == '5' is true). The === operator performs strict equality, meaning it compares both the value and the type without any type coercion (e.g., 5 === '5' is false)." },
    { id: "js_2", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "Explain what 'hoisting' is in JavaScript.", back: "Hoisting is JavaScript's default behavior of moving all declarations to the top of their current scope before code execution. This means you can use a variable or function before it's declared. However, only the declarations are hoisted, not the initializations. For variables declared with var, they are initialized with undefined." },
    { id: "js_3", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "What is a closure in JavaScript?", back: "A closure is a feature where an inner function has access to the variables and parameters of its outer (enclosing) function, even after the outer function has finished executing. This allows for creating private variables and stateful functions." },
    { id: "js_4", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "Describe the difference between var, let, and const.", back: "var: Has function scope, is hoisted, and can be re-declared and updated.\nlet: Has block scope ({}), is hoisted but not initialized (creating a 'temporal dead zone'), and can be updated but not re-declared.\nconst: Has block scope, is hoisted but not initialized, and cannot be updated or re-declared after assignment." },
    { id: "js_5", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "What is the Event Loop and how does it work?", back: "The Event Loop is a concurrency model that allows JavaScript, a single-threaded language, to handle asynchronous operations. It continuously checks the Call Stack and the Callback Queue. If the Call Stack is empty, it takes the first event from the queue and pushes it onto the stack to be executed." },
    { id: "js_6", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "Explain what a Promise is and its three states.", back: "A Promise is an object representing the eventual completion or failure of an asynchronous operation. Its three states are:\nPending: The initial state; neither fulfilled nor rejected.\nFulfilled: The operation completed successfully.\nRejected: The operation failed." },
    { id: "js_7", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "What is the difference between localStorage and sessionStorage?", back: "Both are web storage APIs, but localStorage persists data even after the browser is closed and reopened, with no expiration time. sessionStorage stores data only for the duration of the page session; the data is cleared when the tab or browser is closed." },
    { id: "js_8", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "How does the 'this' keyword work, and how is it different in arrow functions?", back: "In a regular function, the value of 'this' is determined by how the function is called (the call-site). In an arrow function, 'this' is lexically scoped, meaning it inherits the 'this' value from its surrounding (enclosing) scope at the time of its creation." },
    { id: "js_9", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "What is the DOM (Document Object Model)?", back: "The DOM is a programming interface for web documents. It represents the page's structure as a tree of objects, where each object corresponds to a part of the document (like an element or a text node). JavaScript can use the DOM to manipulate the content, structure, and style of a webpage." },
    { id: "js_10", deckId: "javascript_fundamentals", title: SUB_CATEGORY_TITLE, front: "Explain what async/await is.", back: "async/await is syntactic sugar built on top of Promises that makes asynchronous code look and behave more like synchronous code, making it easier to read and write. The async keyword makes a function return a Promise, and the await keyword pauses the function's execution until the awaited Promise is settled." }
];

const practiceTestQuestions = [
    {
        question: "Due to hoisting, what will be logged to the console in the following code? console.log(myVar); var myVar = 10;",
        options: [
            "10",
            "ReferenceError",
            "null",
            "undefined"
        ],
        correctAnswer: "undefined"
    },
    {
        question: "Which of the following has function-level scope rather than block-level scope?",
        options: [
            "let",
            "const",
            "var",
            "Both let and const"
        ],
        correctAnswer: "var"
    },
    {
        question: "A JavaScript closure gives a function access to what?",
        options: [
            "The global scope only.",
            "The scope of the function in which it was defined.",
            "The scope of the function that calls it.",
            "The browser's window object exclusively."
        ],
        correctAnswer: "The scope of the function in which it was defined."
    },
    {
        question: "When an asynchronous operation (like setTimeout) completes, where is its callback function placed before execution?",
        options: [
            "The Call Stack",
            "The Callback Queue (or Task Queue)",
            "The Heap",
            "The Microtask Queue"
        ],
        correctAnswer: "The Callback Queue (or Task Queue)"
    },
    {
        question: "When a Promise is successfully fulfilled, which of the following methods will be executed?",
        options: [
            ".then()",
            ".catch()",
            ".finally()",
            ".error()"
        ],
        correctAnswer: ".then()"
    },
    {
        question: "What is the primary benefit of using async/await?",
        options: [
            "It makes asynchronous operations run faster.",
            "It allows you to write asynchronous code that looks synchronous and is easier to read.",
            "It is the only way to handle multiple asynchronous operations.",
            "It removes the need for the Event Loop."
        ],
        correctAnswer: "It allows you to write asynchronous code that looks synchronous and is easier to read."
    },
    {
        question: "What is 'event bubbling' in the context of the DOM?",
        options: [
            "An event is captured from the top-most ancestor down to the target element.",
            "An event is triggered on the target element and then propagates up through its ancestors.",
            "Only the event on the specific target element is fired.",
            "All events of the same type fire simultaneously."
        ],
        correctAnswer: "An event is triggered on the target element and then propagates up through its ancestors."
    },
    {
        question: "Which browser storage would you use if you need the data to be available even after the user closes and reopens the browser?",
        options: [
            "sessionStorage",
            "Cookies",
            "localStorage",
            "A JavaScript variable"
        ],
        correctAnswer: "localStorage"
    },
    {
        question: "How does an arrow function (=>) determine the value of its this context?",
        options: [
            "It is determined by how the function is called.",
            "It is always bound to the global window object.",
            "It lexically inherits this from its parent scope.",
            "It does not have a this context."
        ],
        correctAnswer: "It lexically inherits this from its parent scope."
    },
    {
        question: "What will be the result of '5' === 5?",
        options: [
            "true",
            "false",
            "undefined",
            "TypeError"
        ],
        correctAnswer: "false"
    }
];

function JS() {
    const { currentUser, updateUserProfile, fetchUserProfile } = useAuth();
    const [view, setView] = useState('options');
    const [questions, setQuestions] = useState(initialFlashcardQuestions);
    const [isLoading, setIsLoading] = useState(false);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [isFlipped, setIsFlipped] = useState(false);
    const [animation, setAnimation] = useState('');
    const [score, setScore] = useState({ correct: 0, wrong: 0 });
    const [isEditMode, setIsEditMode] = useState(false);
    const [roundResults, setRoundResults] = useState({ correct: [], incorrect: [] });
    const [changedAnswers, setChangedAnswers] = useState({});
    const [ptCurrentIndex, setPtCurrentIndex] = useState(0);
    const [selectedAnswer, setSelectedAnswer] = useState(null);
    const [userAnswers, setUserAnswers] = useState([]);
    const [ptScore, setPtScore] = useState(0);
    const [timeLeft, setTimeLeft] = useState(60);
    const [testFinished, setTestFinished] = useState(false);

    // âœ… UPDATED: useEffect now reads from the new nested structure
    useEffect(() => {
            setIsLoading(true);
            
            // First, explicitly reset the questions to the default state.
            // This is crucial for when a user logs out and currentUser becomes null.
            let questionsToLoad = initialFlashcardQuestions.map(q => ({...q}));
    
            // THEN, if a user is logged in and has edits, apply them.
            if (currentUser && currentUser.editedCards) {
                const userEdits = currentUser.editedCards;
                questionsToLoad = questionsToLoad.map(q => {
                    const subCategoryTitle = q.title;
                    const editedAnswer = userEdits[MAIN_CATEGORY_TITLE]?.[subCategoryTitle]?.[q.id];
                    if (editedAnswer) {
                        return { ...q, back: editedAnswer };
                    }
                    return q;
                });
            }
            
            // Set the final state, which will be the default for new/logged-out users
            // or personalized for returning users.
            setQuestions(questionsToLoad);
            setIsLoading(false);
            
            // This effect now correctly depends on currentUser.
        }, [currentUser]);

    useEffect(() => {
        if (view !== 'practiceTest' || testFinished) return;
        if (timeLeft === 0) { setTestFinished(true); return; }
        const timerId = setInterval(() => setTimeLeft(t => t - 1), 1000);
        return () => clearInterval(timerId);
    }, [timeLeft, view, testFinished]);

// âœ… UPDATED: Now uses updateUserProfile from AuthContext
    const updateUserDeckProgress = useCallback(async ({ finalScore, totalQuestions, deckTitle }) => {
    if (!currentUser?.email) return;

    // ... (all the logic for preparing deck data remains the same) ...
    const percentage = totalQuestions > 0 ? finalScore / totalQuestions : 0;
    const isMastered = percentage >= 0.9;
    const deckType = deckTitle.endsWith(" Test") ? "Tests" : "Flashcards";
    const updatedCompleted = JSON.parse(JSON.stringify(currentUser.completedDecks || {}));
    const updatedMastered = JSON.parse(JSON.stringify(currentUser.masteredDecks || {}));
    
    if (isMastered) {
        updatedMastered[deckType] = updatedMastered[deckType] || {};
        updatedMastered[deckType][deckTitle] = true;
        if (updatedCompleted[deckType]?.[deckTitle]) {
            delete updatedCompleted[deckType][deckTitle];
        }
    } else {
        updatedCompleted[deckType] = updatedCompleted[deckType] || {};
        updatedCompleted[deckType][deckTitle] = true;
        if (updatedMastered[deckType]?.[deckTitle]) {
            delete updatedMastered[deckType][deckTitle];
        }
    }

    try {
        // Update completed/mastered decks
        await updateUserProfile(currentUser.email, {
            completedDecks: updatedCompleted,
            masteredDecks: updatedMastered
        });

        // Update accuracy stats
        await fetch(`http://localhost:5000/api/user/${currentUser.email}/stats`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                correct: finalScore,
                total: totalQuestions
            })
        });

        // âœ… FIXED: Call the correct function from your AuthContext
        await fetchUserProfile(currentUser.email);

    } catch (error) {
        console.error("Failed to update user progress:", error);
    }
}, [currentUser, updateUserProfile, fetchUserProfile]); 


    const handleFlip = () => !animation && setIsFlipped(!isFlipped);

    // âœ… FIXED: Now includes the check to prevent firing on practice rounds
    const handleAnswer = (isCorrect) => {
        if (animation || !questions) return;
        const currentQ = questions[currentIndex];
        setAnimation(isCorrect ? 'slide-out-right' : 'slide-out-left');
        setRoundResults(prev => ({
            correct: isCorrect ? [...prev.correct, currentQ] : prev.correct,
            incorrect: !isCorrect ? [...prev.incorrect, currentQ] : prev.incorrect,
        }));

        setTimeout(() => {
            const newCorrectCount = score.correct + (isCorrect ? 1 : 0);
            const newWrongCount = score.wrong + (!isCorrect ? 1 : 0);
            setScore({ correct: newCorrectCount, wrong: newWrongCount });

            // Only update progress if the user has just finished the FULL deck.
            if (currentIndex + 1 === questions.length && questions.length === initialFlashcardQuestions.length) {
                updateUserDeckProgress({
                    finalScore: newCorrectCount,
                    totalQuestions: questions.length,
                    deckTitle: SUB_CATEGORY_TITLE,
                });
            }

            setCurrentIndex(prev => prev + 1);
            setIsFlipped(false);
            setAnimation('');
        }, 500);
    };

    const handleShuffle = () => {
        if (!questions) return;
        setQuestions(prev => [...prev].sort(() => Math.random() - 0.5));
        handleReset();
    };
    
    // âœ… UPDATED: Simplified reset function
    const handleReset = () => {
        setCurrentIndex(0);
        setIsFlipped(false);
        setScore({ correct: 0, wrong: 0 });
        setRoundResults({ correct: [], incorrect: [] });
        setAnimation('reset');
        setTimeout(() => setAnimation(''), 300);
    };

    const handleAnswerChange = (index, newAnswer) => {
        const updatedQuestions = [...questions];
        updatedQuestions[index].back = newAnswer;
        setQuestions(updatedQuestions);
        const questionId = updatedQuestions[index].id;
        setChangedAnswers(prev => ({ ...prev, [questionId]: newAnswer }));
    };

    const startPracticeRound = () => {
        setQuestions(roundResults.incorrect);
        handleReset();
    };

    // âœ… UPDATED: handleSaveChanges now builds the nested object structure
    const handleSaveChanges = async () => {
        if (!currentUser?.email || Object.keys(changedAnswers).length === 0) {
            setIsEditMode(false);
            return;
        }
        const updatedEditedCards = JSON.parse(JSON.stringify(currentUser.editedCards || {}));

        Object.keys(changedAnswers).forEach(cardId => {
            const originalCard = initialFlashcardQuestions.find(q => q.id === cardId);
            if (originalCard) {
                const subCategoryTitle = originalCard.title;
                // Ensure nested structure exists
                updatedEditedCards[MAIN_CATEGORY_TITLE] = updatedEditedCards[MAIN_CATEGORY_TITLE] || {};
                updatedEditedCards[MAIN_CATEGORY_TITLE][subCategoryTitle] = updatedEditedCards[MAIN_CATEGORY_TITLE][subCategoryTitle] || {};
                // Set the new answer
                updatedEditedCards[MAIN_CATEGORY_TITLE][subCategoryTitle][cardId] = changedAnswers[cardId];
            }
        });

        try {
            await updateUserProfile(currentUser.email, { editedCards: updatedEditedCards });
            setChangedAnswers({});
            setIsEditMode(false);
        } catch (error) {
            console.error("Failed to save edited cards:", error);
            alert("An error occurred while saving your changes.");
        }
    };

    const handleAnswerSelect = (answer) => setSelectedAnswer(answer);

    const handleNextQuestion = () => {
        const isCorrect = selectedAnswer === practiceTestQuestions[ptCurrentIndex].correctAnswer;
        const newPtScore = ptScore + (isCorrect ? 1 : 0);
        if (isCorrect) setPtScore(newPtScore);
        setUserAnswers(prev => [...prev, { question: practiceTestQuestions[ptCurrentIndex].question, selected: selectedAnswer, correct: practiceTestQuestions[ptCurrentIndex].correctAnswer, isCorrect }]);
        setSelectedAnswer(null);

        if (ptCurrentIndex + 1 === practiceTestQuestions.length) {
            setTestFinished(true);
            updateUserDeckProgress({
                finalScore: newPtScore,
                totalQuestions: practiceTestQuestions.length,
                deckTitle: `${SUB_CATEGORY_TITLE} Test`,
            });
        } else {
            setPtCurrentIndex(prev => prev + 1);
        }
    };

    const handleTestRestart = () => {
        setView('practiceTest');
        setPtCurrentIndex(0);
        setSelectedAnswer(null);
        setUserAnswers([]);
        setPtScore(0);
        setTimeLeft(60);
        setTestFinished(false);
    };

    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    };

    if (isLoading || !questions) {
        return <div className="loading-fullscreen">Loading Questions...</div>;
    }

    const currentQuestion = questions[currentIndex];

    // --- (The rest of the rendering JSX is unchanged) ---
    if (view === 'options') {
        return (
            <div className="app-container">
                <div className="start-options-container">
                    <div className="start-screen">
                        <h1>Prep Flashcards</h1>
                        <p>Use these cards to practice your responses.</p>
                        <button onClick={() => setView('flashcards')} className="start-button">Start Flashcards</button>
                    </div>
                    <div className="start-screen">
                        <h1>Practice Test</h1>
                        <p>Test your knowledge with multiple-choice questions.</p>
                        <button onClick={handleTestRestart} className="start-button">Start Practice Test</button>
                    </div>
                </div>
            </div>
        );
    }

    if (view === 'flashcards') {
        if (isEditMode) {
            return (
                <div className="app-container">
                    <div className="edit-mode-container">
                        <header className="edit-header">
                            <h2>Edit Answers</h2>
                            <button onClick={handleSaveChanges} className="done-button" title="Save changes">Save</button>
                        </header>
                        <div className="questions-list">
                            {questions.map((q, index) => (
                                <div key={q.id} className="edit-question-item">
                                    <label className="edit-question-label">{q.front}</label>
                                    <textarea className="edit-textarea" value={q.back} onChange={(e) => handleAnswerChange(index, e.target.value)} rows="3" />
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        if (currentIndex >= questions.length && questions.length > 0) {
            const totalAnswered = score.correct + score.wrong;
            const percentage = totalAnswered > 0 ? Math.round((score.correct / totalAnswered) * 100) : 0;
            let titleMessage = "Round Complete!";
            if (totalAnswered > 0) {
                titleMessage = percentage >= 75 ? "You're doing brilliantly!" : percentage >= 50 ? "Good job! Keep practicing." : "Keep practicing, you'll get there!";
            }
            return (
                <div className="app-container">
                    <div className="completion-wrapper">
                        <div className="completion-screen-new">
                            <div className="completion-header"><h1>{titleMessage}</h1></div>
                            <div className="stats-container">
                                <h2>How you're doing</h2>
                                <div className="stats-main">
                                    <div className="stats-percentage">{percentage}%</div>
                                    <div className="stats-bars">
                                        <div className="stat-item">
                                            <span className="stat-label">Know</span>
                                            <div className="stat-bar-container"><div className="stat-bar know-bar" style={{ width: `${(score.correct / totalAnswered) * 100}%` }}></div></div>
                                            <span className="stat-count">{score.correct}</span>
                                        </div>
                                        <div className="stat-item">
                                            <span className="stat-label">Still learning</span>
                                            <div className="stat-bar-container"><div className="stat-bar learning-bar" style={{ width: `${(score.wrong / totalAnswered) * 100}%` }}></div></div>
                                            <span className="stat-count">{score.wrong}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <button onClick={handleReset} className="restart-button-alt" title="Restart Flashcards">Restart Flashcards</button>
                        </div>
                        <div className="your-stats-container">
                            <h2>Your stats</h2>
                            <div className="results-scroll-container">
                                <div className="results-list-section">
                                    <h3>Know ({roundResults.correct.length})</h3>
                                    {roundResults.correct.map((q, i) => <div key={`c-${i}`} className="result-item"><p className="result-item-question">{q.front}</p><p className="result-item-answer">{q.back}</p></div>)}
                                </div>
                                {roundResults.incorrect.length > 0 && (
                                    <div className="results-list-section">
                                        <h3>Still learning ({roundResults.incorrect.length})</h3>
                                        {roundResults.incorrect.map((q, i) => <div key={`i-${i}`} className="result-item"><p className="result-item-question">{q.front}</p><p className="result-item-answer">{q.back}</p></div>)}
                                        <button onClick={startPracticeRound} className="practice-button">Practice 'Still Learning' Cards</button>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        return (
            <div className="app-container">
                <div className="flashcard-container">
                    <header className="header">
                        <button className="header-button" onClick={handleReset} title="Restart"><Icon path={ICONS.undo} /></button>
                        <button className="header-button" onClick={() => setIsEditMode(true)} title="Edit"><Icon path={ICONS.edit} /></button>
                    </header>
                    <main className="main-content">
                        <div className={`card ${isFlipped ? 'is-flipped' : ''} ${animation}`} onClick={handleFlip}>
                            <div className="card-face card-front"><p>{currentQuestion?.front}</p></div>
                            <div className="card-face card-back"><p>{currentQuestion?.back}</p></div>
                        </div>
                    </main>
                    <div className="controls">
                        <button className="control-button wrong-button" onClick={() => handleAnswer(false)}><Icon path={ICONS.x} className="icon large-icon" /></button>
                        <div className="progress-text">
                            <span>{currentIndex + 1} / {questions.length}</span>
                            <div className="score-tracker">
                                <span className="score-item score-wrong"><Icon path={ICONS.x} className="icon score-icon" /> {score.wrong}</span>
                                <span className="score-item score-correct"><Icon path={ICONS.check} className="icon score-icon" /> {score.correct}</span>
                            </div>
                        </div>
                        <button className="control-button correct-button" onClick={() => handleAnswer(true)}><Icon path={ICONS.check} className="icon large-icon" /></button>
                    </div>
                    <footer className="footer">
                        <div className="footer-buttons"><button onClick={handleShuffle} title="Shuffle"><Icon path={ICONS.shuffle} /></button></div>
                    </footer>
                </div>
            </div>
        );
    }

    if (view === 'practiceTest') {
        const currentPtQuestion = practiceTestQuestions[ptCurrentIndex];
        if (testFinished) {
            return (
                <div className="pt-app-container">
                    <div className="pt-results-screen">
                        <h1>Test Complete!</h1>
                        <h2>Your Score: {ptScore} / {practiceTestQuestions.length}</h2>
                        <div className="pt-results-summary">
                            {userAnswers.map((answer, index) => (
                                <div key={index} className={`pt-result-item ${answer.isCorrect ? 'correct' : 'incorrect'}`}>
                                    <p className="pt-result-question">{index + 1}. {answer.question}</p>
                                    <p>Your answer: {answer.selected || "Not Answered"}</p>
                                    {!answer.isCorrect && <p className="pt-correct-answer">Correct answer: {answer.correct}</p>}
                                </div>
                            ))}
                        </div>
                        <button onClick={handleTestRestart} className="pt-start-button">Try Again</button>
                    </div>
                </div>
            );
        }

        return (
            <div className="pt-app-container">
                <div className="pt-test-header">
                    <div className="pt-progress-bar-container">
                        <div className="pt-progress-bar" style={{ width: `${((ptCurrentIndex + 1) / practiceTestQuestions.length) * 100}%` }}></div>
                    </div>
                    <div className="pt-timer">{formatTime(timeLeft)}</div>
                </div>
                <div className="pt-question-container">
                    <h2>Question {ptCurrentIndex + 1} of {practiceTestQuestions.length}</h2>
                    <p className="pt-question-text">{currentPtQuestion.question}</p>
                    <div className="pt-options">
                        {currentPtQuestion.options.map((option, index) => (
                            <button key={index} className={`pt-option-btn ${selectedAnswer === option ? 'selected' : ''}`} onClick={() => handleAnswerSelect(option)}>
                                {option}
                            </button>
                        ))}
                    </div>
                    <button className="pt-next-button" onClick={handleNextQuestion} disabled={!selectedAnswer}>
                        {ptCurrentIndex === practiceTestQuestions.length - 1 ? 'Finish' : 'Next'}
                    </button>
                </div>
            </div>
        );
    }
}

export default JS;